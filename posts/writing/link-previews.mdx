---
title: "Dissecting link previews..."
publishedAt: "Jan 23"
description: "Link previews grew a lot in popularity lately, but let's see some options of creating one."
status: "public"
---

import DemoLinkPreview from "../../demo/LinkPreview";

<DemoLinkPreview />

Lately, link previews grew in popularity and I'm seeing them more often, especially on tech related websites. I feel like having a small box with an image of the destination that is visible whenever you hover the external link is an _amazing idea_ and I would _love_ to see it more often since it is definitely a nice _subtle_ touch.

There are many methods of creating a link preview component, let's go through some of them and see what are strenghts and weaknesses they have.

## Using Microlink's screenshot API

This is definitely the most _popular_ option that I've seen so far, due to the fact that it's really easy to use and also the images get regularly updated.

The images received from [Microlink](https://microlink.io/) are being automatically cached, so you don't need to worry about it.

### But... who ?

Microlink's API will handle all the logic of taking the screenshot, so what is left for us is to create the UI part and also to adjust the URL with some query parameters.

Below is an implementation of the `LinkPreview` component in Next.js. Additionally, I am using the `Image` component from Next.js, the `HoverCard` primitive from [Radix-UI](https://www.radix-ui.com/docs/primitives/components/hover-card) and the `encode` from qss package in this example (query parameters encoding), but feel free to play with it.

```typescript
import React from "react";
import Image from "next/image";
import { useTheme } from "next-themes";
import { encode } from "qss";
import * as HoverCard from "@radix-ui/react-hover-card";

interface IProps {
  url: string;
}

const microlinkURL = "https://api.microlink.io";

const LinkPreview: React.FC<IProps> = ({ url, children }) => {
  const { theme } = useTheme(); // either "light" or "dark"

  const params = encode({
    url,
    screenshot: true,
    meta: false,
    embed: "screenshot.url",
    colorScheme: theme,
  });

  const screenshotURL = `${microlinkURL}/?${params}`;

  return (
    <HoverCard.Root>
      <HoverCard.Trigger href={url} target="_blank">
        {children}
      </HoverCard.Trigger>
      <HoverCard.Content side="top" sideOffset={5}>
        <Image
          src={screenshotURL}
          width={200}
          height={128}
          quality={50}
          layout="fixed"
        />
      </HoverCard.Content>
    </HoverCard.Root>
  );
};

export default LinkPreview;
```

#### Notes

- `colorScheme` can be either `light` or `dark`. This parameter is optional, having the default value to `light`.

There are many other parameters that can be applied in order to achieve the desired result which can be found [here](https://github.com/microlinkhq/browserless).

Also, don't forget to add the Microlink API url in your `next.config.js`

```javascript
/** @type {import('next').NextConfig} */
module.exports = {
  reactStrictMode: true,
  images: {
    domains: ["api.microlink.io"],
  },
};
```

This option seems _lovely_ since we've just created a component, where our only concern was the UI, that would automatically generate screenshots which are going to be regularly updated (once the cache gets invalidated).

### Issues that I've faced

It is _very slow_ due to the fact that it has the `waitUntil` flag set to `networkidle2`, which means that once the cache gets invalidated, it will crawl to the link that you want to screenshot and wait until there are no more that 2 requests in the last 500ms. That results in a bad performance and horrible UX since there would always be an user from time to time that would have to wait **a lot** of time until the image is processed.

Let's say that we can get over this issue, but there is one more. I've experimented this method many times and I can say that the results were _inconsistent_. Most of the web apps that I wanted to snapshot had certain loading states or animations, which ended in images that felt _imcomplete_.

From my experience, trying to capture your Twitter account will result in _almost blank_ images most of the time.

![My Twitter screenshotted by Microlink](/link-previews/my-twitter.png)

## Static File Serving

A good yet _simple_ method in which you take screenshots from all websites that you want to preview and throw them into the `public/` folder of the app.

### Component implementation

I'm going to use the same setup as for the example from above.

The only difference is one additional prop, `imagePath` that will be the path to the image from the `public/` folder.

```typescript
import React from "react";
import Image from "next/image";
import * as HoverCard from "@radix-ui/react-hover-card";

interface IProps {
  url: string;
  imagePath: string;
}

const LinkPreview: React.FC<IProps> = ({ url, imagePath, children }) => {
  return (
    <HoverCard.Root>
      <HoverCard.Trigger href={url} target="_blank">
        {children}
      </HoverCard.Trigger>
      <HoverCard.Content side="top" sideOffset={5}>
        <Image
          src={imagePath}
          width={200}
          height={128}
          quality={50}
          layout="fixed"
        />
      </HoverCard.Content>
    </HoverCard.Root>
  );
};

export default LinkPreview;
```

### IMO

This option performs _way better_ than the previous one without doubt.

However, I feel like this method is a pain to maintain, making new screenshots and deploying every now and then. This is suitable only if either the content of the preview is unlikely to change often or you don't care about the freshness of the screenshot.

## Creating screenshots via Github Actions and adding them to the File Static Server

Looking at the previous options strengths, we can see that the first one had images that were _up-to-date_ and the second one was _performing_ really well.

What if we could find a work-around and combine those two to obtain a Link Preview component that is using images from the File Static Server, but those are being updated at an interval of time ?

Checkout this [live example](https://github-actions-images.vercel.app/) and also feel free to look at the [source code](https://github.com/mariusflorescu/github-actions-images).

### The idea behind

Well, the idea is to create a _Github Action_ that will run at an interval of time a script that creates screenshots, updates the `public/` folder and the pushes back the changes to the repository.

### Cronjob

The action that runs can be found inside of `.github/workflows/screenshots.js` and it looks like this:

```yaml
name: Generate screenshots

on:
  schedule:
    - cron: "0 */12 * * *"

jobs:
  cron:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: DerYeger/yarn-setup-action@master
        with:
          node-version: 16
      - name: yarn install
        run: yarn
      - name: make screenshots
        run: yarn run screenshots
      - name: push to repository
        run: |
          git config --global user.name 'Your Name'
          git config --global user.email 'username@users.noreply.github.com'
          git pull origin main
          git commit -am "Automated screenshots"
          git push
```

What happens is _straight-forward_. It runs every 12 hours, installs dependencies, runs script that is generating the screenshots and then pushes them back to the repository.

### The script

The example script that you can find inside of `.github/functions/generateScreenshots.js` firstly cleans the `public/` folder, receives a list of links that need to be visited and screenshotted and by using any Headless Browser it goes, waits for some time (5 seconds in the example), takes the screenshots for both light and dark theme and saves them to the `public/` folder.

As you can see, the images are being resized before saving, because a link preview would generally be rendered at small sizes (`200x128` in this example).

In addition to that, the images are saved as `webp`, since they are _optimised for the web_, having small sizes, which is an absolute advantage.

#### Notes

I'm using `browserless` in this example because it has a strong out of the box configuration, that _tricks_ many web apps against their bot protection. As an example, if you try to screenshot **Twitter** with Puppeteer or Playwright, with no prior configuration, you would see that the screenshot would like this:

![Twitter Browser no longer supported](/link-previews/twitter.png)

I've chosen going for an image _preload_ and a normal image tag in favor of the `Image` component because until the image isn't visible the optimizing won't be done, so for the first user that comes in and tries the link preview will see the hover card _blank_ until the optimization and caching is done. Even though the period where the card is blank is _very_ short, it's still annoying from an user perspective.

This is how the live example looks like:

![Live example](/link-previews/example.gif)

**Be aware** that this is just an example which will work for the _perfect_ scenario, but what if an image _fails_ to be screenshotted ? In this example, the entire script would just fail and no screenshots would be updated, but we could find ways of _keeping_ the old images and updating as many as we can.

## Another methods

There are many other ways of creating this component, such as creating an _api route_ that takes the screenshot and caches the response (will run in the same issue as using the Microlink API though) or even using a _storage solution_ where the screenshots would be updated periodically.

## Conclusion

**Which one is the best ?**

My answer is _definetly_ it depends on the situation.

If the website isn't updating often, I would choose creating the screenshots myself.

If I wanted to keep them up-to-date, to be easy to implement and accept the trade-off until the response is cached, I would choose Microlink's API.

And if I had the time to implement, constantly upgrade and maintain my own solution I would go for that.

IMO, rarely you would see a solution that is _the best_ for each situation. In the end, that's the beauty of programming, having a number of possible use cases will result in almost the same number of solutions 🤪.
